import{_ as a,o as s,c as l,O as n}from"./chunks/framework.a9f788d3.js";const h=JSON.parse('{"title":"内部类","description":"","frontmatter":{},"headers":[],"relativePath":"java/基础/内部类.md"}'),o={name:"java/基础/内部类.md"},e=n(`<h1 id="内部类" tabindex="-1">内部类 <a class="header-anchor" href="#内部类" aria-label="Permalink to &quot;内部类&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><h3 id="方法内部类-局部内部类" tabindex="-1">方法内部类 (局部内部类) <a class="header-anchor" href="#方法内部类-局部内部类" aria-label="Permalink to &quot;方法内部类 (局部内部类)&quot;">​</a></h3><p>如果一个类是定义在一个 <code>方法内部</code> 的，那么就是一个 方法内部类 <code>局部</code>: 只有当前所属的方法才能使用它，出了这个方法就无法使用</p><blockquote><p>如果希望访问所在方法的局部变量，那么这个局部变量必须是 <code>final</code></p><ul><li>new 出来的对象在堆内存当中</li><li>局部变量是跟着方法走的，在栈内存当中</li><li>方法运行结束后，立刻出栈，局部变量就会立刻消失</li><li>但是 new 出来的对象会在堆当中持续存在，直到垃圾回收消失</li></ul><p>从 java8 开始，只要局部变量始终没有去改变，那么 final 关键字可以省略<br> 编译器会自动判断该变量是否有在程序中改变 . 如果没有，则会自动添加 final 关键字; 否则，不会添加</p></blockquote><h3 id="匿名内部类" tabindex="-1">匿名内部类 <a class="header-anchor" href="#匿名内部类" aria-label="Permalink to &quot;匿名内部类&quot;">​</a></h3><p>如果接口的实现类（或者是父类的子类） 只需要使用唯一的一次，那么这种情况下就可以省略该类的定义，而改为使用 匿名内部类</p><h3 id="普通内部类" tabindex="-1">普通内部类 <a class="header-anchor" href="#普通内部类" aria-label="Permalink to &quot;普通内部类&quot;">​</a></h3><p>将一个类定义在一个类中, 有具体的名字</p><h3 id="静态内部类" tabindex="-1">静态内部类 <a class="header-anchor" href="#静态内部类" aria-label="Permalink to &quot;静态内部类&quot;">​</a></h3><p>在普通类的基础上, 对类添加了 static 关键词进行修饰</p><blockquote><p>静态内部类, 一定程度上可以看作另一个顶级类<br> 普通的内部类, 需要依赖外部类对象创建<br> 静态内部类不需要</p></blockquote><ul><li>静态内部类的加载时机: 使用到内部类时加载<br> 即如果外部类没有使用到内部类, 内部类是不会随着外部类一起加载的<br> 与静态代码块加载时机不同, 可以用于实现懒加载</li><li>静态内部类使用的时候, 如果未使用到外部类, 则不会加载外部类</li></ul><h2 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h2><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">外部类</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">内部类 对象名</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> 外部类</span><span style="color:#89DDFF;">().</span><span style="color:#A6ACCD;">new 内部类</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 如果有重名</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 获取方法内的局部变量：</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">变量名</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 获取内部类的变量：</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(this.</span><span style="color:#A6ACCD;">变量名</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 获取外部类的变量：</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">外部类</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">this</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">变量名</span><span style="color:#89DDFF;">);</span></span></code></pre></div><h2 id="反射获取内部类" tabindex="-1">反射获取内部类 <a class="header-anchor" href="#反射获取内部类" aria-label="Permalink to &quot;反射获取内部类&quot;">​</a></h2><blockquote><p>内部类, 需要使用 <code>$</code> 符号, 连接父子类, 不能直接打点, 否则会抛异常找不到对应内部类</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// ps: 可以通过 javac 命令直接编译 java 文件, 进行查看测试</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  DIRECTION_CLASS </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Class</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forName</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">org.springframework.data.domain.Sort$Direction</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span></code></pre></div>`,18),p=[e];function t(c,r,i,D,y,F){return s(),l("div",null,p)}const A=a(o,[["render",t]]);export{h as __pageData,A as default};
