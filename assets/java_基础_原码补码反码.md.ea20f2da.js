import{_ as a,o as t,c as e,O as s}from"./chunks/framework.a9f788d3.js";const _=JSON.parse('{"title":"原码 补码 反码","description":"","frontmatter":{},"headers":[],"relativePath":"java/基础/原码补码反码.md"}'),l={name:"java/基础/原码补码反码.md"},n=s(`<h1 id="原码-补码-反码" tabindex="-1">原码 补码 反码 <a class="header-anchor" href="#原码-补码-反码" aria-label="Permalink to &quot;原码 补码 反码&quot;">​</a></h1><blockquote><p>计算机在进行数值运算的时候, 是通过 &#39;补码&#39; 表示的每个数值</p></blockquote><p>示例:</p><table><thead><tr><th>数值</th><th>原码</th><th>反码</th><th>补码</th><th>说明</th></tr></thead><tbody><tr><td>-128</td><td>1000 000</td><td>1111 1111</td><td>1000 000</td><td>0 没有正负之分, 因此原用来表示-0 的值用于表示 -128</td></tr><tr><td>127</td><td>0111 1111</td><td>0111 1111</td><td>0111 1111</td><td></td></tr><tr><td>-1</td><td>1000 0001</td><td>1111 1110</td><td>1111 1111</td><td></td></tr></tbody></table><h2 id="原码" tabindex="-1">原码 <a class="header-anchor" href="#原码" aria-label="Permalink to &quot;原码&quot;">​</a></h2><p>以二进制表示的数字</p><h2 id="反码" tabindex="-1">反码 <a class="header-anchor" href="#反码" aria-label="Permalink to &quot;反码&quot;">​</a></h2><ul><li>正数<br> 与原码相同</li><li>负数<br> 保留符号位不变, 其余按位取反</li></ul><h2 id="补码" tabindex="-1">补码 <a class="header-anchor" href="#补码" aria-label="Permalink to &quot;补码&quot;">​</a></h2><ul><li>正数<br> 原码相同</li><li>负数<br> 在反码的基础上, 加 1. <blockquote><p>即 相对于原码, 按位取反再加 1<br> 如果想要得到原码, 则仅需要将当前补码看作原码进行求补</p></blockquote></li></ul><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">-3: 原码 1011 补码 1101</span></span>
<span class="line"><span style="color:#A6ACCD;">-1: 原码 1001 补码 1111</span></span>
<span class="line"><span style="color:#A6ACCD;">(-3)+(-1): 计算机中 补码相加 1 1100  =&gt;  对应原码: 1100  =&gt; 对应数值: -4</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>上述所讲的原码, 补码, 反码仅是一种简单的获取结果的方法</p><p>以下是相关的实际原理:</p><p><strong>补码 <code>two&#39;s complement</code></strong><br> 即 对 2 求补, 这个 2 指的是计数系统的容量（模），就是计数系统所能表示的状态数<br> 例如在 4 位二进制中, 这个 2 就是 2^4^</p><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">1 个符号位 + 3 个数值位</span></span>
<span class="line"><span style="color:#A6ACCD;">=&gt; 则容量为 2^4^</span></span>
<span class="line"><span style="color:#A6ACCD;">=&gt; x 的补码为 (2^4^+x)%2^4^</span></span></code></pre></div><p><strong>反码 <code>ones&#39; complement</code></strong><br> 即 对 1 求补, 这个 1 指的是计数系统所能表示的最大的值<br> 例如 8 位二进制中, 这个 1 就是 <code>1111 1111</code>, 在 1 位十进制中就是 9</p><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">1 个符号位 + 3 个数值位</span></span>
<span class="line"><span style="color:#A6ACCD;">=&gt; 则 1 表示 2^4^-1</span></span>
<span class="line"><span style="color:#A6ACCD;">=&gt; x 的反码为 (2^4^-1+x)%(2^4^-1)</span></span></code></pre></div><h3 id="补码的意义" tabindex="-1">补码的意义 <a class="header-anchor" href="#补码的意义" aria-label="Permalink to &quot;补码的意义&quot;">​</a></h3><p>就是把负数变成它对应的正数, 然后参与运算<br> 那么就不用进行减法运算了，只要使用加法就行了</p><h3 id="补码为什么等于反码加-1" tabindex="-1">补码为什么等于反码加 1 <a class="header-anchor" href="#补码为什么等于反码加-1" aria-label="Permalink to &quot;补码为什么等于反码加 1&quot;">​</a></h3><p>这个结论, 仅仅只是因为反码和补码的推导关系得出, 并没有实际意义</p><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">x 的反码 = (2^4^-1+x)%(2^4^-1)  </span></span>
<span class="line"><span style="color:#A6ACCD;">x 的补码 = (2^4^+x)%2^4^  </span></span>
<span class="line"><span style="color:#A6ACCD;">=&gt; 补码 = 反码 + 1</span></span></code></pre></div><h3 id="为什么补码的第一位数可以被看作符号位" tabindex="-1">为什么补码的第一位数可以被看作符号位 <a class="header-anchor" href="#为什么补码的第一位数可以被看作符号位" aria-label="Permalink to &quot;为什么补码的第一位数可以被看作符号位&quot;">​</a></h3><p>补码实际没有符号位, 所有的位数都需要参加运算, 这样才能满足计算机计算的需求, 因为计算机是不认识正负的.</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><p><a href="https://blog.csdn.net/qq_45472866/article/details/114779170" target="_blank" rel="noreferrer">补码的符号位为什么能参与运算</a></p>`,28),o=[n];function r(p,c,d,i,h,b){return t(),e("div",null,o)}const C=a(l,[["render",r]]);export{_ as __pageData,C as default};
