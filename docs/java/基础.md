# 基础

## 概念

### java 的三大特性

封装，继承，多态

### jdk, jre, jvm 的区别

> 三者属于包含关系

- JDK(Java SE Development Kit)，Java 标准开发包。
  它提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常用的 Java 类库等。
- JRE( Java Runtime Environment) ，Java 运行环境。
  用于解释执行 Java 的字节码文件。普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装 JDK 来编译、调试程序。
- JVM(Java Virtual Mechinal)，Java 虚拟机，是 JRE 的一部分。
  它是整个 java 实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行 java 字节码文件的虚拟计算机。所有平台的上的 JVM 向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。

## 快速体验

```shell
# 提前准备一份 HelloWorld.java 代码

# 将java代码编译为class文件
javac HelloWorld.java
# 如果java代码中带有中文字符，会报错 -> 错误: 编码GBK的不可映射字符
# 可以用如下的方法进行编译
javac -encoding utf-8 HelloWorld.java

# 执行class文件 不能带class后缀
java HelloWorld

# 反编译class文件
javap -c HelloWorld
javap -c -verbose HelloWorld
```

## 规范及语法

### java 命名

1. 对于变量名和方法名，`_` 和 `$` 不作为标识符的第一个字符，因为这两个字符对于内部类具有特殊含义
2. 类名，接口名 采用 大小写混合 的形式，即每个单词的首字母大写，其余小写
3. 变量名和方法名也采用大小写混合的方式，但第一个单词的首字母小写, 也叫做 驼峰命名法
4. 常量名完全大写，并且用下划线 `_` 作为标识符中各个单词的分隔符
5. 方法名应该使用动词表示
   类名与接口名 使用名词表示
6. 变量名应该能够标识一定的含义，因此尽量不使用单个字符作为变量名，临时性变量名除外

#### 一些常见的命名区别

##### status 和 state

- state: 用于多个状态能够互相切换的情况. 如 水的三种状态
- status: 用于没有状态互相切换的情况. 如 http status code

### java 注释

```java
// 单行注释

/*
多行注释
*/

/**
* 方法, 类名, 常量等的文档注释
*/
```

## java 相关的一些分类

### 基本数据类型

> String 不是基本数据类型, 底层是数组实现的

| 种类    | 字节数 | 表示范围                                                   |
| ------- | ------ | ---------------------------------------------------------- |
| boolean | 1      | true/false                                                 |
| char    | 2      | 表示一个字符, 汉字也算一个字符                             |
| byte    | 1      | -2^7^~2^7^-1                                               |
| short   | 2      | -2^15^~2^15^-1                                             |
| int     | 4      | -2^31^~2^31^-1                                             |
| long    | 8      | -2^63^~2^63^-1                                             |
| float   | 4      | 由 1 位表示正负的符号位、8 位指数位和 23 位有效数字位组成  |
| double  | 8      | 由 1 位表示正负的符号位、11 位指数位和 52 位有效数字位组成 |

### 可访问性

- private(私有)
- default(包)
- protected(子类)
- public(公有)

### 类的分类

- 基本类
- 接口类
- 抽象类
- 内部类
- 枚举类

### 程序种类

- 内嵌于 web 文件中, 由浏览器来查看的 Applet (浏览器调用 java 虚拟机执行)
- 可独立运行的 Application
- 服务端的 Servlets

## 数值运算

### 原码 补码 反码

> 计算机在进行数值运算的时候, 是通过 '补码' 表示的每个数值

示例:
| 数值 | 原码 | 反码 | 补码 | 说明 |
| - | - | - | - | - |
| -128 | 1000 000 | 1111 1111 |1000 000 | 0 没有正负之分, 因此原用来表示-0 的值用于表示 -128 |
| 127 | 0111 1111 | 0111 1111 | 0111 1111 |
| -1 | 1000 0001 | 1111 1110 | 1111 1111 |

#### 原码

> 以二进制表示的数字

#### 反码

- 正数与原码相同
- 负数, 保留符号位不变, 其余按位取反

#### 补码

- 正数与原码相同
- 负数, 在反码的基础上, 加 1.
  > 即 相对于原码, 按位取反再加 1
  > 如果想要得到原码, 则需要将当前补码看作原码进行求补

#### 总结

上述所讲的原码, 补码, 反码仅是一种简单的获取结果的方法, 以下是相关的实际原理:

**补码 `two's complement`**
即 对 2 求补, 这个 2 指的是计数系统的容量（模），就是计数系统所能表示的状态数, 例如在 4 位二进制中, 这个 2 就是 2^4^
比如:
1 个符号位+3 个数值位
=> 则容量为 2^4^
=> x 的补码为 (2^4^+x)%2^4^

**反码 `ones' complement`**
即 对 1 求补, 这个 1 指的是计数系统所能表示的最大的值, 例如 8 位二进制中, 这个 1 就是 `1111 1111`, 在 1 位十进制中就是 9
比如:
1 个符号位 + 3 个数值位
=> 则 1 表示 2^4^-1
=> x 的反码为 (2^4^-1+x)%(2^4^-1)

**补码的意义就是把负数变成它对应的正数, 然后参与运算**
那么就不用进行减法运算了，只要使用加法就行了

**补码为什么等于反码加 1**
这个结论, 仅仅只是因为反码和补码的推导关系得出, 实际并没有意义
上方我声明了两个等式:
x 的反码 = (2^4^-1+x)%(2^4^-1)
x 的补码 = (2^4^+x)%2^4^
=> 补码 = 反码 + 1

**为什么补码的第一位数可以被看作符号位**
补码实际没有符号位, 所有的位数都需要参加运算, 这样才能满足计算机计算的需求, 因为计算机是不认识正负的.

[参考博客](https://blog.csdn.net/qq_45472866/article/details/114779170)

### 运算符

- `>>` 右移 (符号位不进行处理）
- `>>>` 无符号右移
- `<<` 左移 (符号位不进行处理）
- `<<<` 无符号左移
- `&` 与
- `|` 或
- `~` 非
- `^` 异或

算术运算符：（两个箭头符号的运算符）

> 正数右移，高位用 0 补；负数右移，高位用 1 补
> 正数或者负数左移，低位都是用 0 补

逻辑运算符：（三个箭头符号的运算符）

> 不考虑符号位

## 字符串

### String, StringBuilder, StringBuffer

- String
  > 字符串是常量，在创建之后不能被修改, 实际是一个被 final 修饰的数组
- StringBuilder(线程不安全)
  > 底层也是一个数组
  > 但是没有被 final 修饰，可以改变长度
  > StringBuilder 在内存中始终是一个数组，占用空间少，效率高，如果超出了 StringBuilder 的容量，会自动的扩容
- StringBuffer(线程安全)
  > 类似 StringBuilder

### String 常用方法

```java
// 返回当前字符串的长度
int length()

// 查找 字符/字符串 在该字符串第一次出现的位置
int indexOf(int ch)
int indexOf(String str)
// 查找 字符/字符串 在该字符串最后一次出现的位置
int lastIndexOf(int ch)
int lastIndexOf(String str)

// 获取字符串中指定位置的字符
char charAt(int Index)


// 获取从指定位置开始到结束的子字符串 (包含开始位置, 不包含结束位置)
String subString(int beginIndex, int endIndex)

// 将字符串分割为子字符串，返回字符串数组
String[] split(String regex)
String[] split(String regex, int limit)

// 返回去除了字符串前后空格的字符串
String trim()

// 将字符串转换为小写
String toLowerCase()
// 将字符串转换为大写
String toUpperCase()

//  将该字符串转换为byte数组
byte[] getBytes()

// 将 字符/字符数组 转为字符串
String valueOf(char[])
String.valueOf(char)

// 字符转数字
// 先转为字符串，再由字符串转数字
Integer.parseInt(String.valueOf(c))
```

## 数组

### 赋值

```java
// 静态初始化
String[] words1 = new String[]{"i", "love", "games"};
// 简化写法
String[] words2 = {"i", "love", "games"};

// 动态初始化
String[] words3 = new String[10];/* 这种方式, 则必须指定大小 */
words3 = new String[] {"i", "love", "games"};

```

### Arrays--数组的工具类

```java
// 数组转List
public static <T> List<T> asList(T... a)
// 将数组转为流
public static <T> Stream<T> stream(T[] array)
// 排序
public static void sort(int[] a)
public static void sort(int[] a, int fromIndex, int toIndex)
public static void parallelSort(int[] a)
// 二分查找
public static int binarySearch(long[] a, long key)
// 指定元素填充数组
public static void fill(long[] a, long val)
// 复制数组, 多余长度以 null 填充
public static <T> T[] copyOf(T[] original, int newLength)
// 设置指定数组的所有元素, 使用提供的生成器函数计算每个元素
public static <T> void setAll(T[] array, IntFunction<? extends T> generator)
```
