# 多态

## 基本概念

### 理论

代码中体现子类 => 父类指向子类对象

### 格式

- 父类名称 对象名 = new 子类名称();
- 接口名称 对象名 = new 实现类名称();

### 好处

无论右边new任何子类的对象, 等号左边调用的方法都不会产生任何变化

## 访问成员变量的两种方法

1. 直接通过 `对象名称` 访问成员变量, 看等号左边是谁, 则优先用谁, 没有则向上查找
    > 编译看左边, 运行也看左边
2. 间接通过 `对象方法` 访问变量, 该方法属于谁, 则优先用谁, 没有则向上查找
    > 编译看左边, 运行看右边

示例代码:

```java
@Test
public void test(){
    Fu fu = new Fu();
    System.out.println(fu.num);    //输出5
    System.out.println(fu.getNum());    //输出5
    Zi zi = new Zi();
    System.out.println(zi.num);    //输出8
    System.out.println(zi.getNum());    //输出8
    Fu a = new Zi();
    System.out.println(a.num);    //输出5
    System.out.println(a.getNum());    //输出8
}
class Fu{
    public int num = 5;
    public int getNum(){
        return num;
    }
}
class Zi extends Fu{
    public int num = 8;
    public int getNum(){
        return num;
    }
}

```

## 对象转型

> 类型强转时, 编译器不会报错, 运行后才会报错 => 抛出 ClassCaseException 类型转换异常

### 对象向上转型

父类 指向 子类
> 小转大 安全

### 对象向下转型

子类 转向 父类
> 大转小 不安全

## 判断对象的实际类型

```java
对象 instanceof 类名
```

常用思路: 先判断类型, 再进行类型强转

## 装箱与拆箱

```java
// 装箱
Integer a = 243;//编译器转译为：Integer a = Integer.valueOf(243)

// 拆箱
int b = a;//编译器会修改成：int b = a.intValue();

// 缓存[-128,127]之间的数字
Integer i1 = Integer.valueOf(-128);
Integer i2 = Integer.valueOf(-128);
System.out.println(i1 == i2);//true 因为 -128 在缓存范围内
System.out.println(i1.equals(i2));//true

Integer i3 = Integer.valueOf(128);
Integer i4 = Integer.valueOf(128);
System.out.println(i3 == i4);//false 因为 128 不在缓存范围内
System.out.println(i3.equals(i4));//true

// Integer对象将会自动生成一个缓存数组cache[256]，其值为[-128,127]之间，如果请求封装的数字在这之间，将会直接调用，否则才会new一个新的对象  

// 因此，i1 和 i2 引用的是同一个对象，“==”操作的结果为 true
// 而 i3 和 i4 的结果为 false
```
